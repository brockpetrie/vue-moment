{"version":3,"file":"vue-moment.min.js","sources":["../vue-moment.js"],"sourcesContent":["module.exports = {\n  install(Vue, options) {\n    const moment = options && options.moment ? options.moment : require('moment');\n\n    Object.defineProperties(Vue.prototype, {\n      $moment: {\n        get() {\n          return moment;\n        },\n      },\n    });\n\n    Vue.moment = moment;\n\n    Vue.filter('moment', (...args) => {\n      args = Array.prototype.slice.call(args);\n      const input = args.shift();\n      let date;\n\n      if (Array.isArray(input) && typeof input[0] === 'string') {\n        // If input is array, assume we're being passed a format pattern to parse against.\n        // Format pattern will accept an array of potential formats to parse against.\n        // Date string should be at [0], format pattern(s) should be at [1]\n        date = moment(input[0], input[1], true);\n      } else if (typeof input === 'number') {\n        if (input.toString().length < 12) {\n          // If input is an integer with fewer than 12 digits, assume Unix seconds...\n          date = moment.unix(input);\n        } else {\n          // ..otherwise, assume milliseconds.\n          date = moment(input);\n        }\n      } else {\n        // Otherwise, throw the input at moment and see what happens...\n        date = moment(input);\n      }\n\n      if (!input || !date.isValid()) {\n        // Log a warning if moment couldn't reconcile the input. Better than throwing an error?\n        console.warn('Could not build a valid `moment` object from input.');\n        return input;\n      }\n\n      function parse(...args) {\n        args = Array.prototype.slice.call(args);\n        const method = args.shift();\n\n        switch (method) {\n          case 'add': {\n            /*\n            * Mutates the original moment by adding time.\n            * http://momentjs.com/docs/#/manipulating/add/\n            */\n\n            const addends = args.shift()\n              .split(',')\n              .map(Function.prototype.call, String.prototype.trim);\n            const obj = {};\n\n            for (let n = 0; n < addends.length; n++) {\n              const addend = addends[n].split(' ');\n              obj[addend[1]] = addend[0];\n            }\n            date.add(obj);\n            break;\n          }\n\n          case 'subtract': {\n            /*\n            * Mutates the original moment by subtracting time.\n            * http://momentjs.com/docs/#/manipulating/subtract/\n            */\n\n            const subtrahends = args.shift()\n              .split(',')\n              .map(Function.prototype.call, String.prototype.trim);\n            const obj = {};\n\n            for (let n = 0; n < subtrahends.length; n++) {\n              const subtrahend = subtrahends[n].split(' ');\n              obj[subtrahend[1]] = subtrahend[0];\n            }\n            date.subtract(obj);\n            break;\n          }\n\n          case 'from': {\n            /*\n            * Display a moment in relative time, either from now or from a specified date.\n            * http://momentjs.com/docs/#/displaying/fromnow/\n            */\n\n            let from = 'now';\n            let removeSuffix = false;\n\n            if (args[0] === 'now') args.shift();\n            // If valid, assume it is a date we want the output computed against.\n            if (moment(args[0]).isValid()) from = moment(args.shift());\n\n            if (args[0] === true) {\n              args.shift();\n              removeSuffix = true;\n            }\n\n            if (from !== 'now') {\n              date = date.from(from, removeSuffix);\n            } else {\n              date = date.fromNow(removeSuffix);\n            }\n            break;\n          }\n\n          case 'diff': {\n            /*\n            * Mutates the original moment by doing a difference with another date.\n            * http://momentjs.com/docs/#/displaying/difference/\n            */\n\n            let referenceTime = moment();\n            let units = '';\n            let float = false;\n\n            if (moment(args[0]).isValid()) {\n              // If valid, assume it is a date we want the output computed against.\n              referenceTime = moment(args.shift());\n            } else if (args[0] === null || args[0] === 'now') {\n              // If null or 'now', remove argument and proceed with default referenceTime.\n              args.shift();\n            }\n\n            if (args[0]) units = args.shift();\n\n            if (args[0] === true) float = args.shift();\n\n            date = date.diff(referenceTime, units, float);\n            break;\n          }\n\n          case 'calendar': {\n            /*\n            * Formats a date with different strings depending on how close\n            * to a certain date (today by default) the date is.\n            * http://momentjs.com/docs/#/displaying/calendar-time/\n            */\n\n            let referenceTime = moment();\n            let formats = {};\n\n            if (moment(args[0]).isValid()) {\n              // If valid, assume it is a date we want the output computed against.\n              referenceTime = moment(args.shift());\n            } else if (args[0] === null || args[0] === 'now') {\n              // If null or 'now', remove argument and proceed with default referenceTime.\n              args.shift();\n            }\n\n            if (typeof args[0] === 'object') formats = args.shift();\n\n            date = date.calendar(referenceTime, formats);\n            break;\n          }\n\n          case 'utc': {\n            /*\n            * Mutates the original moment by converting to UTC\n            * https://momentjs.com/docs/#/manipulating/utc/\n            */\n            date.utc();\n            break;\n          }\n\n          case 'timezone': {\n            /*\n            * Mutates the original moment by converting to a new timezone.\n            * https://momentjs.com/timezone/docs/#/using-timezones/converting-to-zone/\n            */\n            date.tz(args.shift());\n            break;\n          }\n\n          default: {\n            /*\n            * Formats a date by taking a string of tokens and replacing\n            * them with their corresponding values.\n            * http://momentjs.com/docs/#/displaying/format/\n            */\n\n            const format = method;\n            date = date.format(format);\n          }\n        }\n\n        if (args.length) parse.apply(parse, args);\n      }\n\n      parse.apply(parse, args);\n\n      return date;\n    });\n\n    Vue.filter('duration', (...args) => {\n      /*\n      * Basic pass-through filter for leveraging moment.js's ability\n      * to manipulate and display durations.\n      * https://momentjs.com/docs/#/durations/\n      */\n      args = Array.prototype.slice.call(args);\n      const input = args.shift();\n      const method = args.shift();\n\n      function createDuration(time) {\n        if (!Array.isArray(time)) time = [time];\n        const result = moment.duration(...time);\n        if (!result.isValid()) console.warn('Could not build a valid `duration` object from input.');\n        return result;\n      }\n      let duration = createDuration(input);\n\n      if (method === 'add' || method === 'subtract') {\n        // Generates a duration object and either adds or subtracts it\n        // from our original duration.\n        const durationChange = createDuration(args);\n        duration[method](durationChange);\n      } else if (duration && duration[method]) {\n        // This gives a full proxy to moment.duration functions.\n        duration = duration[method](...args);\n      }\n\n      return duration;\n    });\n  },\n};\n"],"names":["module","Vue","options","moment","require","defineProperties","prototype","filter","args","input","Array","slice","call","shift","date","isArray","toString","length","unix","isValid","warn","parse","method","addends","split","map","Function","String","trim","obj","n","addend","add","subtrahends","subtrahend","subtract","from","removeSuffix","fromNow","referenceTime","units","float","diff","formats","_typeof","calendar","utc","tz","format","apply","createDuration","time","result","duration","console","durationChange"],"mappings":"ulBAAAA,wBACUC,EAAKC,OACLC,EAASD,GAAWA,EAAQC,OAASD,EAAQC,OAASC,SAErDC,iBAAiBJ,EAAIK,0CAGfH,QAKTA,OAASA,IAETI,OAAO,SAAU,kDAAIC,qCAEjBC,KADCC,MAAMJ,UAAUK,MAAMC,KAAKJ,IACfK,QACfC,cAEAJ,MAAMK,QAAQN,IAA8B,iBAAbA,EAAM,GAIhCN,EAAOM,EAAM,GAAIA,EAAM,IAAI,GACR,iBAAVA,GACZA,EAAMO,WAAWC,OAAS,GAErBd,EAAOe,KAAKT,GAOdN,EAAOM,IAGXA,IAAUK,EAAKK,yBAEVC,KAAK,uDACNX,WAGAY,2CAASb,qCAEVc,KADCZ,MAAMJ,UAAUK,MAAMC,KAAKJ,IACdK,eAEZS,OACD,cAMGC,EAAUf,EAAKK,QAClBW,MAAM,KACNC,IAAIC,SAASpB,UAAUM,KAAMe,OAAOrB,UAAUsB,MAC3CC,KAEGC,EAAI,EAAGA,EAAIP,EAAQN,OAAQa,IAAK,KACjCC,EAASR,EAAQO,GAAGN,MAAM,OAC5BO,EAAO,IAAMA,EAAO,KAErBC,IAAIH,aAIN,mBAMGI,EAAczB,EAAKK,QACtBW,MAAM,KACNC,IAAIC,SAASpB,UAAUM,KAAMe,OAAOrB,UAAUsB,MAC3CC,KAEGC,EAAI,EAAGA,EAAIG,EAAYhB,OAAQa,IAAK,KACrCI,EAAaD,EAAYH,GAAGN,MAAM,OACpCU,EAAW,IAAMA,EAAW,KAE7BC,SAASN,aAIX,WAMCO,EAAO,MACPC,GAAe,EAEH,QAAZ7B,EAAK,IAAcA,EAAKK,QAExBV,EAAOK,EAAK,IAAIW,YAAWiB,EAAOjC,EAAOK,EAAKK,WAElC,IAAZL,EAAK,OACFK,WACU,KAGJ,QAATuB,EACKtB,EAAKsB,KAAKA,EAAMC,GAEhBvB,EAAKwB,QAAQD,aAKnB,WAMCE,EAAgBpC,IAChBqC,EAAQ,GACRC,GAAQ,EAERtC,EAAOK,EAAK,IAAIW,YAEFhB,EAAOK,EAAKK,SACP,OAAZL,EAAK,IAA2B,QAAZA,EAAK,MAE7BK,QAGHL,EAAK,KAAIgC,EAAQhC,EAAKK,UAEV,IAAZL,EAAK,KAAaiC,EAAQjC,EAAKK,WAE5BC,EAAK4B,KAAKH,EAAeC,EAAOC,aAIpC,eAOCF,EAAgBpC,IAChBwC,KAEAxC,EAAOK,EAAK,IAAIW,YAEFhB,EAAOK,EAAKK,SACP,OAAZL,EAAK,IAA2B,QAAZA,EAAK,MAE7BK,QAGgB,WAAnB+B,EAAOpC,EAAK,MAAiBmC,EAAUnC,EAAKK,WAEzCC,EAAK+B,SAASN,EAAeI,aAIjC,QAKEG,gBAIF,aAKEC,GAAGvC,EAAKK,2BAWPmC,EAAS1B,IACRR,EAAKkC,OAAOA,GAInBxC,EAAKS,QAAQI,EAAM4B,MAAM5B,EAAOb,YAGhCyC,MAAM5B,EAAOb,GAEZM,MAGLP,OAAO,WAAY,kDAAIC,qCAOnBC,KADCC,MAAMJ,UAAUK,MAAMC,KAAKJ,IACfK,QACbS,EAASd,EAAKK,iBAEXqC,EAAeC,GACjBzC,MAAMK,QAAQoC,KAAOA,GAAQA,QAC5BC,EAASjD,EAAOkD,mBAAYF,WAC7BC,EAAOjC,WAAWmC,QAAQlC,KAAK,yDAC7BgC,MAELC,EAAWH,EAAezC,MAEf,QAAXa,GAA+B,aAAXA,EAAuB,KAGvCiC,EAAiBL,EAAe1C,KAC7Bc,GAAQiC,QACZ,GAAIF,GAAYA,EAAS/B,GAAS,eAEnBA,aAAWd,WAG1B6C"}